package com.hummingbee.system;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.time.LocalDate;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Timer;
import java.util.TimerTask;

/**
 * Usage class that reads and writes serialized file storing all sprinkler usages
 * @author Nick
 *
 */
public class Usage {
	// constants
	// total usages serialized file path
	private static final String TOTAL_USAGES_FILE_PATH = "resources/total_usages.ser";
	// sprinkler usages serialized file path
	private static final String SPRINKLER_USAGES_FILE_PATH = "resources/sprinkler_usages.ser";
	
	// usages map
	private static HashMap<String, Double> totalUsages = null;
	private static HashMap<String, LinkedList<DayUsage>> sprinklerUsages = null;
	
	// updates the stored usages and GUI
	public static void update(String sprinklerId, double usage) {
		// retrieve usages map if the system is starting up
		if (totalUsages == null) {
			totalUsages = readTotalUsages();
		}
		if (sprinklerUsages == null) {
			sprinklerUsages = readSprinklerUsages();
		}
		
		// update the total value for the sprinkler
		Double oldUsage = totalUsages.containsKey(sprinklerId) ? totalUsages.get(sprinklerId) : 0;
		totalUsages.put(sprinklerId, oldUsage + usage);
		// update the value for the sprinkler
		LocalDate today = LocalDate.now();
		LinkedList<DayUsage> sprinklerUsage = sprinklerUsages.containsKey(sprinklerId) ?
				sprinklerUsages.get(sprinklerId) : new LinkedList<DayUsage>();
		
		// write usages map
		writeTotalUsage(totalUsages);
		writeSprinklerUsage(sprinklerUsages);
		// update display
		
	}
	
	/**
	 * gets the usage of a particular sprinkler
	 * @param sprinklerId of the sprinkler usage to retrieve
	 * @return sprinkler usage
	 */
	public static double getUsage(String sprinklerId) {
		// retrieve usages map if the system is starting up
		if (totalUsages == null) {
			totalUsages = readTotalUsages();
		}
		
		return totalUsages.containsKey(sprinklerId) ? totalUsages.get(sprinklerId) : 0;
	}
	
	/**
	 * reads usages from serialized file in resources folder
	 * @return HashMap<String, Double> of serialized usages, constructs a new HashMap if file doesn't exist
	 */
	public static HashMap<String, Double> readTotalUsages() {
		HashMap<String, Double> map;
		File usagesFile = new File(TOTAL_USAGES_FILE_PATH);
		if (usagesFile.exists()) {
			try {
				FileInputStream fis = new FileInputStream(TOTAL_USAGES_FILE_PATH);
				ObjectInputStream ois = new ObjectInputStream(fis);
				map = (HashMap<String, Double>) ois.readObject();
				ois.close();
			} catch (IOException e) {
				// what to do on IOException? display a message?
				map = new HashMap<String, Double>();
				e.printStackTrace();
			} catch (Exception e) {
				map = new HashMap<String, Double>();
				e.printStackTrace();
			}
		}
		else {
			map = new HashMap<String, Double>();
		}
		
		return map;
	}
	
	/**
	 * reads sprinkler usages from serialized file in resources folder
	 * @return HashMap<String, LinkedList<DayUsage>> of serialized usages
	 * constructs a new HashMap if file doesn't exist
	 */
	public static HashMap<String, LinkedList<DayUsage>> readSprinklerUsages() {
		HashMap<String, LinkedList<DayUsage>> map;
		File usagesFile = new File(TOTAL_USAGES_FILE_PATH);
		if (usagesFile.exists()) {
			try {
				FileInputStream fis = new FileInputStream(SPRINKLER_USAGES_FILE_PATH);
				ObjectInputStream ois = new ObjectInputStream(fis);
				map = (HashMap<String, LinkedList<DayUsage>>) ois.readObject();
				ois.close();
			} catch (IOException e) {
				// what to do on IOException? display a message?
				map = new HashMap<String, LinkedList<DayUsage>>();
				e.printStackTrace();
			} catch (Exception e) {
				map = new HashMap<String, LinkedList<DayUsage>>();
				e.printStackTrace();
			}
		}
		else {
			map = new HashMap<String, LinkedList<DayUsage>>();
		}
		
		return map;
	}
	
	/**
	 * serializes the HashMap and writes it to .ser file
	 * @param map the HashMap to serialize
	 */
	private static void writeTotalUsage(HashMap<String, Double> map) {
		try {
			FileOutputStream fos = new FileOutputStream(TOTAL_USAGES_FILE_PATH);
	        ObjectOutputStream oos = new ObjectOutputStream(fos);
	        oos.writeObject(map);
	        oos.close();
		} catch (IOException e) {
			// what to do on IOException? display a message?
			e.printStackTrace();
		}
	}
	
	/**
	 * serializes the HashMap and writes it to .ser file
	 * @param map the HashMap to serialize
	 */
	private static void writeSprinklerUsage(HashMap<String, LinkedList<DayUsage>> map) {
		try {
			FileOutputStream fos = new FileOutputStream(TOTAL_USAGES_FILE_PATH);
	        ObjectOutputStream oos = new ObjectOutputStream(fos);
	        oos.writeObject(map);
	        oos.close();
		} catch (IOException e) {
			// what to do on IOException? display a message?
			e.printStackTrace();
		}
	}
	
	/**
	 * resets usages, data will be lost
	 */
	public static void resetUsages() {
		writeTotalUsage(new HashMap<String, Double>());
	}
	
	/**
	 * Inner class to help record and update usages while sprinklers are active
	 * @author Nick
	 *
	 */
	class UpdateTimer extends Timer {
		// constants
		// the program will update the usage every 10 minutes (10 seconds in real time)
		private static final int UPDATE_INTERVAL = 10;
		
		// data members
		private HashMap<Sprinkler, Date> sprinklers;
		
		public UpdateTimer() {
			sprinklers = new HashMap<Sprinkler, Date>();
		}
		
		/**
		 * start the timer with a task to update the usage every interval
		 */
		public void start() {
			schedule(new TimerTask() {
				public void run() {
					Iterator<Sprinkler> iterator = sprinklers.keySet().iterator();
					while (iterator.hasNext()) {
						Sprinkler sprinkler = iterator.next();
						Date lastUpdate = sprinklers.get(sprinkler);
						Date now = new Date();
						double elapsedSeconds = (now.getTime() - lastUpdate.getTime()) / 1000;
						update(sprinkler.getId(), sprinkler.getWaterFlow() * elapsedSeconds);
						sprinklers.put(sprinkler, now);
					}
				}
			}, UPDATE_INTERVAL * 1000);
		}
		
		/**
		 * stop the timer and update the left over usage since last update
		 */
		public void stop() {
			// get the time of termination
			Date stopTime = new Date();
			// get the number of minutes (seconds in real time)
			// that have passed since the sprinkler started
			double time = (stopTime.getTime() - startTime.getTime()) / 1000;
			// update the sprinkler usage
			Usage.update(id, WATER_FLOW * time);
			cancel();
		}
		
		public void removeSprinkler(String sprinklerId) {
			
		}
	}

}
